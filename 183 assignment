{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "64-XCLdSBBuc"
      },
      "source": [
        "# Deep Neural Networks - Programming Assignment\n",
        "## Comparing Linear Models and Multi-Layer Perceptrons\n",
        "\n",
        "**Student Name:** Basavaraj\n",
        "**Student ID:** 2024ac05293  \n",
        "\n",
        "**Student Name:** GUNDAPPA MENGA   \n",
        "**Student ID:** 2024ac05088  \n",
        "\n",
        "**Student Name:** SHETGAONKAR PARAG MOHAN  \n",
        "**Student ID:** 2024ac05220\n",
        "\n",
        "**Student Name:** VENKATA VIVEK VANTEDDU  \n",
        "**Student ID:** 2024ac05828  \n",
        "\n",
        "**Date:** 26/12/2025\n",
        "\n",
        "---\n",
        "\n",
        "## ⚠️ IMPORTANT INSTRUCTIONS\n",
        "\n",
        "1. **Complete ALL sections** marked with `TODO`\n",
        "2. **DO NOT modify** the `get_assignment_results()` function structure\n",
        "3. **Track training time** for both models using `time.time()`\\n\n",
        "4. **Store loss_history** in both model classes\n",
        "5. **Calculate ALL metrics** (accuracy, precision, recall, F1)\n",
        "6. **Fill get_assignment_results()** with ALL required fields\n",
        "7. **PRINT the results** - Auto-grader needs visible output!\n",
        "8. **Run all cells** before submitting (Kernel → Restart & Run All)\n",
        "\n",
        "**SCORING:**\n",
        "- Missing fields = 0 marks for that section\n",
        "- Non-executed notebook = 0 marks\n",
        "- Cleared outputs = 0 marks\n",
        "---"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 163,
      "metadata": {
        "id": "3Pti5nJuBBue",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "21f1410c-48bd-4bdf-a93e-55f748ba9801"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "✓ Libraries imported successfully\n"
          ]
        }
      ],
      "source": [
        "# Import required libraries\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "import time\n",
        "import warnings\n",
        "warnings.filterwarnings('ignore')\n",
        "from sklearn.datasets import load_breast_cancer\n",
        "# Set random seed for reproducibility\n",
        "np.random.seed(42)\n",
        "from sklearn.metrics import accuracy_score, mean_squared_error , mean_absolute_error, r2_score\n",
        "from sklearn.datasets import fetch_openml\n",
        "from sklearn.datasets import fetch_california_housing\n",
        "print('✓ Libraries imported successfully')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "jNyOCAuwBBue"
      },
      "source": [
        "## Section 1: Dataset Selection and Loading\n",
        "\n",
        "**Requirements:**\n",
        "- ≥500 samples\n",
        "- ≥5 features\n",
        "- Public dataset (UCI/Kaggle)\n",
        "- Regression OR Classification problem"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 164,
      "metadata": {
        "id": "9QfsHoIkBBuf",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "de8d7dca-039e-4220-8adc-e23698091290"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Dataset: UCI Abalone Dataset \n",
            "Source: Public UCI dataset \n",
            "Samples: 4177, Features: 9\n",
            "Problem Type: regression\n",
            "Primary Metric: r2\n"
          ]
        }
      ],
      "source": [
        "\n",
        "#datset\n",
        "# data = load_breast_cancer()\n",
        "# adult = fetch_openml(\n",
        "#     name=\"adult\",\n",
        "#     version=2,\n",
        "#     as_frame=True\n",
        "# )\n",
        "# data = adult.data\n",
        "\n",
        "import pandas as pd\n",
        "\n",
        "columns = [\n",
        "    \"Sex\", \"Length\", \"Diameter\", \"Height\",\n",
        "    \"Whole_weight\", \"Shucked_weight\",\n",
        "    \"Viscera_weight\", \"Shell_weight\", \"Rings\"\n",
        "]\n",
        "\n",
        "url = \"https://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data\"\n",
        "\n",
        "data = pd.read_csv(url, names=columns)\n",
        "\n",
        "# Dataset information (TODO: Fill these)\n",
        "dataset_name = \"UCI Abalone Dataset \"\n",
        "dataset_source = \"Public UCI dataset \"  # UCI Machine Learning Repository\n",
        "n_samples = data.shape[0]      # Total number of rows\n",
        "n_features = data.shape[1]-1     # Number of features (excluding target)\n",
        "problem_type = \"regression\"  # \"regression\" or \"binary_classification\" or \"multiclass_classification\"\n",
        "\n",
        "#TODO\n",
        "# Problem statement (TODO: Write 2-3 sentences)\n",
        "problem_statement = \"\"\"\n",
        "The Abalone dataset contains physical measurements of marine mollusks and aims to predict the number of shell rings,which is correlated with age.\n",
        "Since the relationship between physical attributes and age is non-linear, this dataset is well-suited for comparing linear regression with a multi-layer perceptron.\"\n",
        "\"\"\"\n",
        "\n",
        "# Primary evaluation metric (TODO: Fill this)\n",
        "primary_metric = \"r2\"  # e.g., \"recall\", \"accuracy\", \"rmse\", \"r2\"\n",
        "\n",
        "# Metric justification (TODO: Write 2-3 sentences)\n",
        "metric_justification = \"\"\"R² represents the proportion of variance in the target variable (Rings, which correlates with abalone age) that is explained by the input features.\"\n",
        "\"\"\"\n",
        "# print(type(adult.data))\n",
        "print(f\"Dataset: {dataset_name}\")\n",
        "print(f\"Source: {dataset_source}\")\n",
        "print(f\"Samples: {data.shape[0]}, Features: {data.shape[1]}\")\n",
        "print(f\"Problem Type: {problem_type}\")\n",
        "print(f\"Primary Metric: {primary_metric}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2XOI6I6JBBuf"
      },
      "source": [
        "## Section 2: Data Preprocessing\n",
        "\n",
        "Preprocess your data:\n",
        "1. Handle missing values\n",
        "2. Encode categorical variables\n",
        "3. Split into train/test sets\n",
        "4. Scale features"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 165,
      "metadata": {
        "id": "mfQProeUBBuf",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "00a70072-5d81-44fb-90b7-b21bf1df0be6"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Train samples: (3341, 9)\n",
            "Test samples: (836, 9)\n",
            "Split ratio: 80.0%\n",
            "train shape shape (3341, 9)\n"
          ]
        }
      ],
      "source": [
        "# TODO: Preprocess your data\n",
        "# 1. Separate features (X) and target (y)\n",
        "# X = pd.DataFrame(data.data, columns=data.feature_names)\n",
        "# y = pd.Series(data.target)\n",
        "X = data.drop(\"Rings\", axis=1)\n",
        "y = data[\"Rings\"]\n",
        "\n",
        "#encode columns\n",
        "X = pd.get_dummies(X, columns=[\"Sex\"], drop_first=True)\n",
        "\n",
        "\n",
        "\n",
        "# TODO: Train-test split\n",
        "X_train, X_test, y_train, y_test = train_test_split(\n",
        "    X, y, test_size=0.2, random_state=42\n",
        ")\n",
        "\n",
        "# TODO: Feature scaling\n",
        "scaler = StandardScaler()\n",
        "X_train = scaler.fit_transform(X_train)\n",
        "X_test = scaler.transform(X_test)\n",
        "\n",
        "train_samples = X_train.shape[0]\n",
        "test_samples = X_test.shape[0]\n",
        "train_test_ratio = train_samples / test_samples\n",
        "\n",
        "print(f\"Train samples: {X_train.shape}\")\n",
        "print(f\"Test samples: {X_test.shape}\")\n",
        "print(f\"Split ratio: {0.8:.1%}\")\n",
        "print(\"train shape shape\",X_train.shape)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Elw6-stdBBuf"
      },
      "source": [
        "## Section 3: Baseline Model Implementation\n",
        "\n",
        "Implement from scratch (NO sklearn models!):\n",
        "- Linear Regression (for regression)\n",
        "- Logistic Regression (for binary classification)\n",
        "- Softmax Regression (for multiclass classification)\n",
        "\n",
        "**Must include:**\n",
        "- Forward pass (prediction)\n",
        "- Loss computation\n",
        "- Gradient computation\n",
        "- Gradient descent loop\n",
        "- Loss tracking"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 166,
      "metadata": {
        "id": "bvQ2rWfWBBuf"
      },
      "outputs": [],
      "source": [
        "#linear Regression Model class\n",
        "class LinearRegressionScratch:\n",
        "    def __init__(self, learning_rate=0.01, n_iterations=3000):\n",
        "        self.lr = learning_rate\n",
        "        self.n_iterations = n_iterations\n",
        "        self.loss_history = []\n",
        "\n",
        "    #function to fit the model\n",
        "    def fit(self, X, y):\n",
        "        n_samples, n_features = X.shape\n",
        "        self.w = np.zeros(n_features)\n",
        "        self.b = 0\n",
        "\n",
        "        for _ in range(self.n_iterations):\n",
        "            y_pred = np.dot(X, self.w) + self.b\n",
        "\n",
        "            # calculate Mean Squared Error\n",
        "            loss = np.mean((y - y_pred) ** 2)\n",
        "            self.loss_history.append(loss)\n",
        "\n",
        "            #update weights\n",
        "            dw = (2 / n_samples) * np.dot(X.T, (y_pred - y))\n",
        "            db = (2 / n_samples) * np.sum(y_pred - y)\n",
        "\n",
        "            self.w -= self.lr * dw\n",
        "            self.b -= self.lr * db\n",
        "\n",
        "        return self\n",
        "\n",
        "    def predict(self, X):\n",
        "        return np.dot(X, self.w) + self.b\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 167,
      "metadata": {
        "id": "grpLqkmTBBuf",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "0ec0ce54-0ff3-4803-a880-b5e79d7f494c"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Training baseline model...\n",
            "✓ Baseline training completed in 1.64s\n",
            "✓ Loss decreased from 109.1796 to 4.8651\n"
          ]
        }
      ],
      "source": [
        "# Train baseline model\n",
        "print(\"Training baseline model...\")\n",
        "Lgm_start = time.time()\n",
        "\n",
        "# Initialize and train your baseline model\n",
        "baseline_model = LinearRegressionScratch(learning_rate=0.01, n_iterations=3000)\n",
        "baseline_model.fit(X_train, y_train)\n",
        "\n",
        "#  Make predictions\n",
        "baseline_predictions = baseline_model.predict(X_test)\n",
        "\n",
        "\n",
        "\n",
        "baseline_training_time = time.time() - Lgm_start\n",
        "print(f\"✓ Baseline training completed in {baseline_training_time:.2f}s\")\n",
        "print(f\"✓ Loss decreased from {baseline_model.loss_history[0]:.4f} to {baseline_model.loss_history[-1]:.4f}\")\n",
        "\n",
        "# Store loss explicitly\n",
        "baseline_initial_loss = baseline_model.loss_history[0]\n",
        "baseline_final_loss = baseline_model.loss_history[-1]"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "IQpy-zZSBBug"
      },
      "source": [
        "## Section 4: Multi-Layer Perceptron Implementation\n",
        "\n",
        "Implement MLP from scratch with:\n",
        "- At least 1 hidden layer\n",
        "- ReLU activation for hidden layers\n",
        "- Appropriate output activation\n",
        "- Forward propagation\n",
        "- Backward propagation\n",
        "- Gradient descent"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 168,
      "metadata": {
        "id": "r2wqZVlfBBug"
      },
      "outputs": [],
      "source": [
        "class MLP:\n",
        "    def __init__(self, architecture, learning_rate=0.01, n_iterations=5000):\n",
        "        \"\"\"\n",
        "        architecture: [input_dim, hidden1, hidden2, ..., output_dim]\n",
        "        \"\"\"\n",
        "        self.architecture = architecture\n",
        "        self.lr = learning_rate\n",
        "        self.n_iterations = n_iterations\n",
        "        self.loss_history = []\n",
        "\n",
        "    # ---------- Activations ----------\n",
        "    def relu(self, z):\n",
        "        return np.maximum(0, z)\n",
        "\n",
        "    def relu_derivative(self, z):\n",
        "        return (z > 0).astype(float)\n",
        "\n",
        "    # ---------- Initialization ----------\n",
        "    def initialize_parameters(self):\n",
        "        self.W = []\n",
        "        self.b = []\n",
        "\n",
        "        for i in range(len(self.architecture) - 1):\n",
        "            in_dim = self.architecture[i]\n",
        "            out_dim = self.architecture[i + 1]\n",
        "\n",
        "            # He initialization (CRITICAL for ReLU)\n",
        "            W = np.random.randn(in_dim, out_dim) * np.sqrt(2 / in_dim)\n",
        "            b = np.zeros((1, out_dim))\n",
        "\n",
        "            self.W.append(W)\n",
        "            self.b.append(b)\n",
        "\n",
        "    # ---------- Forward Propagation ----------\n",
        "    def forward_propagation(self, X):\n",
        "        self.Z = []\n",
        "        self.A = [X]\n",
        "\n",
        "        # Hidden layers (ReLU)\n",
        "        for i in range(len(self.W) - 1):\n",
        "            z = np.dot(self.A[-1], self.W[i]) + self.b[i]\n",
        "            a = self.relu(z)\n",
        "            self.Z.append(z)\n",
        "            self.A.append(a)\n",
        "\n",
        "        # Output layer (LINEAR for regression)\n",
        "        z = np.dot(self.A[-1], self.W[-1]) + self.b[-1]\n",
        "        self.Z.append(z)\n",
        "        self.A.append(z)   # no activation\n",
        "\n",
        "        return z\n",
        "\n",
        "    # ---------- Backward Propagation ----------\n",
        "    def backward_propagation(self, X, y):\n",
        "        m = X.shape[0]\n",
        "        dW = [None] * len(self.W)\n",
        "        db = [None] * len(self.b)\n",
        "\n",
        "        # Output layer gradient (MSE loss)\n",
        "        dz = (self.A[-1].flatten() - y).reshape(-1, 1)\n",
        "\n",
        "        dW[-1] = np.dot(self.A[-2].T, dz) / m\n",
        "        db[-1] = np.mean(dz, axis=0, keepdims=True)\n",
        "\n",
        "        # Hidden layers\n",
        "        for i in reversed(range(len(self.W) - 1)):\n",
        "            dz = np.dot(dz, self.W[i + 1].T) * self.relu_derivative(self.Z[i])\n",
        "            dW[i] = np.dot(self.A[i].T, dz) / m\n",
        "            db[i] = np.mean(dz, axis=0, keepdims=True)\n",
        "\n",
        "        return dW, db\n",
        "\n",
        "    # ---------- Training ----------\n",
        "    def fit(self, X, y):\n",
        "        self.initialize_parameters()\n",
        "        y = np.asarray(y)\n",
        "\n",
        "        for epoch in range(self.n_iterations):\n",
        "            y_hat = self.forward_propagation(X).flatten()\n",
        "\n",
        "            # Mean Squared Error\n",
        "            loss = np.mean((y - y_hat) ** 2)\n",
        "            self.loss_history.append(loss)\n",
        "\n",
        "            dW, db = self.backward_propagation(X, y)\n",
        "\n",
        "            for i in range(len(self.W)):\n",
        "                self.W[i] -= self.lr * dW[i]\n",
        "                self.b[i] -= self.lr * db[i]\n",
        "\n",
        "            # Optional debug print (good for viva)\n",
        "            if epoch % 500 == 0:\n",
        "                print(f\"Epoch {epoch}, Loss: {loss:.4f}\")\n",
        "\n",
        "        return self\n",
        "\n",
        "    # ---------- Prediction ----------\n",
        "    def predict(self, X):\n",
        "        return self.forward_propagation(X).flatten()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 169,
      "metadata": {
        "id": "foCVrsiTBBug",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "61521215-7875-4f3a-cdcd-150ff4980aa6"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Training MLP...\n",
            "Epoch 0, Loss: 113.4522\n",
            "Epoch 500, Loss: 4.2729\n",
            "Epoch 1000, Loss: 4.1740\n",
            "Epoch 1500, Loss: 4.1416\n",
            "Epoch 2000, Loss: 4.1334\n",
            "Epoch 2500, Loss: 4.0635\n",
            "✓ MLP training completed in 11.04s\n",
            "✓ Loss decreased from 113.4522 to 3.9762\n"
          ]
        }
      ],
      "source": [
        "# Train MLP\n",
        "print(\"Training MLP...\")\n",
        "mlp_start_time = time.time()\n",
        "\n",
        "# TODO: Define your architecture and train MLP\n",
        "mlp_architecture = [X_train.shape[1], 32,8, 1]  # Example: [n_features, 16, 8, 1]\n",
        "mlp_model = MLP(architecture=mlp_architecture, learning_rate=0.05, n_iterations=3000)\n",
        "mlp_model.fit(X_train, y_train)\n",
        "\n",
        "# TODO: Make predictions\n",
        "mlp_predictions = mlp_model.predict(X_test)\n",
        "\n",
        "mlp_training_time = time.time() - mlp_start_time\n",
        "print(f\"✓ MLP training completed in {mlp_training_time:.2f}s\")\n",
        "print(f\"✓ Loss decreased from {mlp_model.loss_history[0]:.4f} to {mlp_model.loss_history[-1]:.4f}\")\n",
        "\n",
        "# Store loss explicitly\n",
        "mlp_initial_loss = mlp_model.loss_history[0]\n",
        "mlp_final_loss = mlp_model.loss_history[-1]"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "bf38UvC0BBug"
      },
      "source": [
        "## Section 5: Evaluation and Metrics\n",
        "\n",
        "Calculate appropriate metrics for your problem type"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 170,
      "metadata": {
        "id": "dei5PjKGBBug",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "2b68a538-aa09-4817-fce4-23255a29df71"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Baseline Model Performance:\n",
            "{'MSE': 5.026721840887425, 'RMSE': 2.242035200635223, 'MAE': 1.6206206310973115, 'R2': 0.5356467154232925}\n",
            "\n",
            "MLP Model Performance:\n",
            "{'MSE': 4.4174297693903934, 'RMSE': 2.1017682482591638, 'MAE': 1.4918964667063248, 'R2': 0.5919312650008844}\n"
          ]
        }
      ],
      "source": [
        "def calculate_metrics(y_true, y_pred):\n",
        "    mse = mean_squared_error(y_true, y_pred)\n",
        "    rmse = float(np.sqrt(mse))\n",
        "    mae = mean_absolute_error(y_true, y_pred)\n",
        "    r2 = r2_score(y_true, y_pred)\n",
        "\n",
        "    return {\n",
        "        \"MSE\": mse,\n",
        "        \"RMSE\": rmse,\n",
        "        \"MAE\": mae,\n",
        "        \"R2\": r2\n",
        "    }\n",
        "\n",
        "# Calculate metrics for both models\n",
        "baseline_metrics = calculate_metrics(y_test, baseline_predictions)\n",
        "mlp_metrics = calculate_metrics(y_test, mlp_predictions)\n",
        "\n",
        "\n",
        "baseline_mse = baseline_metrics['MSE']\n",
        "baseline_rmse = baseline_metrics['RMSE']\n",
        "baseline_mae = baseline_metrics['MAE']\n",
        "baseline_r2 = baseline_metrics['R2']\n",
        "\n",
        "mlp_mse = mlp_metrics['MSE']\n",
        "mlp_rmse = mlp_metrics['RMSE']\n",
        "mlp_mae = mlp_metrics['MAE']\n",
        "mlp_r2 = mlp_metrics['R2']\n",
        "\n",
        "print(\"Baseline Model Performance:\")\n",
        "print(baseline_metrics)\n",
        "\n",
        "print(\"\\nMLP Model Performance:\")\n",
        "print(mlp_metrics)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "q4SZCkf3BBug"
      },
      "source": [
        "## Section 6: Visualization\n",
        "\n",
        "Create visualizations:\n",
        "1. Training loss curves\n",
        "2. Performance comparison\n",
        "3. Additional domain-specific plots"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 171,
      "metadata": {
        "id": "hPqji5F0BBuh",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 410
        },
        "outputId": "0e0e7b10-1352-4763-f186-376b991f0084"
      },
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 800x400 with 1 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAArcAAAGJCAYAAACQBRs3AAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAUe5JREFUeJzt3Xl4VOX9/vH7zCQzScjGmhANi2wRWURUjCuWVECqbK1L0QL2p7WAFnctgmJV1KpVELG2FdCiuHwFK1UUUbBqZBNUliIoW5UEBZJAIMksz++PSYYMSSDLZE4S3q/rGjNz1s88czLeeXjOOZYxxggAAABoAhx2FwAAAACEC+EWAAAATQbhFgAAAE0G4RYAAABNBuEWAAAATQbhFgAAAE0G4RYAAABNBuEWAAAATQbhFgAAAE0G4RZAgzVmzBh16NChVuvef//9siwrvAWhyZkzZ44sy9L27dvtLgVAmBBuAdSYZVnVeixbtszuUm0xZswYxcfH211GtS1YsECDBw9Wq1at5HK5lJaWpiuuuEIffvih3aUBQI1ZxhhjdxEAGpd//vOfIa9ffPFFLVmyRC+99FLI9J///OdKSUmp9X48Ho/8fr/cbneN1/V6vfJ6vYqJian1/mtrzJgxeuONN3Tw4MGI77smjDG67rrrNGfOHPXp00e//OUvlZqaqt27d2vBggVas2aNPv30U5177rl2l1pvfD6fPB6P3G43Pf1AExFldwEAGp9rrrkm5PXnn3+uJUuWVJh+tEOHDikuLq7a+4mOjq5VfZIUFRWlqCi+4o7liSee0Jw5czRx4kQ9+eSTIeFu0qRJeumll5psGxYWFqpZs2ZyOp1yOp12lwMgjBiWAKBe9O/fXz169NCaNWt04YUXKi4uTn/84x8lSW+99ZaGDBmitLQ0ud1uderUSX/605/k8/lCtnH0mNvt27fLsiw9/vjjev7559WpUye53W6dddZZWrVqVci6lY25tSxLEyZM0MKFC9WjRw+53W6ddtppWrx4cYX6ly1bpjPPPFMxMTHq1KmT/vrXv4Z9HO/rr7+uvn37KjY2Vq1atdI111yj77//PmSZnJwcjR07VieffLLcbrfatm2roUOHhowRXb16tQYOHKhWrVopNjZWHTt21HXXXXfMfR8+fFjTpk1TRkaGHn/88Urf17XXXquzzz47+Pq7777Tr371K7Vo0UJxcXE655xz9O9//ztknWXLlsmyLL322muaOnWqTjrpJCUkJOiXv/yl8vPzVVxcrIkTJ6pNmzaKj4/X2LFjVVxcHLKNss9p3rx56tatm2JiYtS3b199/PHHIcvt2LFD48aNU7du3RQbG6uWLVvqV7/6VYXxs2XjapcvX65x48apTZs2Ovnkk0Pm1bQ9CwsLddtttyk9PV1ut1vdunXT448/rqP/MbQmxxyA8Giaf5IDaBD27t2rwYMH66qrrtI111wTHKIwZ84cxcfH69Zbb1V8fLw+/PBDTZkyRQUFBfrzn/983O2+/PLLOnDggH73u9/Jsiw99thjGjFihL777rvj9vZ+8sknevPNNzVu3DglJCRo+vTpGjlypHbu3KmWLVtKktauXatBgwapbdu2mjp1qnw+nx544AG1bt267o1Sas6cORo7dqzOOussTZs2Tbm5uXr66af16aefau3atUpOTpYkjRw5Uhs2bNBNN92kDh06aM+ePVqyZIl27twZfH3JJZeodevWuvvuu5WcnKzt27frzTffPG477Nu3TxMnTqxWz2Vubq7OPfdcHTp0SDfffLNatmypuXPn6vLLL9cbb7yh4cOHhyw/bdo0xcbG6u6779bWrVs1Y8YMRUdHy+FwaP/+/br//vv1+eefa86cOerYsaOmTJkSsv7y5cv16quv6uabb5bb7dazzz6rQYMGaeXKlerRo4ckadWqVfrss8901VVX6eSTT9b27ds1a9Ys9e/fXxs3bqzwrwTjxo1T69atNWXKFBUWFlb6PqvTnsYYXX755froo4/029/+Vqeffrree+893XHHHfr+++/1l7/8pUJbH++YAxBGBgDqaPz48ebor5OLLrrISDLPPfdcheUPHTpUYdrvfvc7ExcXZ4qKioLTRo8ebdq3bx98vW3bNiPJtGzZ0uzbty84/a233jKSzNtvvx2cdt9991WoSZJxuVxm69atwWlffvmlkWRmzJgRnHbZZZeZuLg48/333wenbdmyxURFRVXYZmVGjx5tmjVrVuX8kpIS06ZNG9OjRw9z+PDh4PRFixYZSWbKlCnGGGP2799vJJk///nPVW5rwYIFRpJZtWrVcesq7+mnnzaSzIIFC6q1/MSJE40k85///Cc47cCBA6Zjx46mQ4cOxufzGWOM+eijj4wk06NHD1NSUhJc9uqrrzaWZZnBgweHbDczMzPkMzYm8DlJMqtXrw5O27Fjh4mJiTHDhw8PTqvsOMrOzjaSzIsvvhicNnv2bCPJnH/++cbr9YYsXzZv27ZtxpjqtefChQuNJPPggw+GTP/lL39pLMsKOb6qe8wBCB+GJQCoN263W2PHjq0wPTY2Nvj8wIED+umnn3TBBRfo0KFD+u9//3vc7V555ZVq3rx58PUFF1wgKfDP5seTlZWlTp06BV/36tVLiYmJwXV9Pp8++OADDRs2TGlpacHlOnfurMGDBx93+9WxevVq7dmzR+PGjQs54W3IkCHKyMgI/lN/bGysXC6Xli1bpv3791e6rbIe3kWLFsnj8VS7hoKCAklSQkJCtZZ/5513dPbZZ+v8888PTouPj9cNN9yg7du3a+PGjSHL/+Y3vwnpRe/Xr1/wBLby+vXrp127dsnr9YZMz8zMVN++fYOv27Vrp6FDh+q9994LDl8pfxx5PB7t3btXnTt3VnJysr744osK7+H6668/bi91ddrznXfekdPp1M033xwy/bbbbpMxRu+++27I9OMdcwDCi3ALoN6cdNJJcrlcFaZv2LBBw4cPV1JSkhITE9W6devgyWj5+fnH3W67du1CXpcF3aoC4LHWLVu/bN09e/bo8OHD6ty5c4XlKptWGzt27JAkdevWrcK8jIyM4Hy3261HH31U7777rlJSUnThhRfqscceU05OTnD5iy66SCNHjtTUqVPVqlUrDR06VLNnz64wjvVoiYmJkgJ/XFS35srqPfXUU0PeU5mj2zkpKUmSlJ6eXmG63++v8Ll36dKlwr66du2qQ4cO6ccff5QUGDc8ZcqU4LjXVq1aqXXr1srLy6v0OOrYsePx3ma12nPHjh1KS0ur8IdBddtCCj3mAIQX4RZAvSnfs1YmLy9PF110kb788ks98MADevvtt7VkyRI9+uijkiS/33/c7VbV+2aqcWXDuqxrh4kTJ+qbb77RtGnTFBMTo8mTJ+vUU0/V2rVrJQVOWHrjjTeUnZ2tCRMm6Pvvv9d1112nvn37HvNSZBkZGZKkr7/+ul7qrqqdw9n+N910kx566CFdccUVeu211/T+++9ryZIlatmyZaXHUWXH49Fq257H0tiOOaCxI9wCiKhly5Zp7969mjNnjv7whz/oF7/4hbKyskKGGdipTZs2iomJ0datWyvMq2xabbRv316StHnz5grzNm/eHJxfplOnTrrtttv0/vvva/369SopKdETTzwRssw555yjhx56SKtXr9a8efO0YcMGzZ8/v8oazj//fDVv3lyvvPJKhatUVFVzZfWWDSM5uua62rJlS4Vp33zzjeLi4oIn9r3xxhsaPXq0nnjiCf3yl7/Uz3/+c51//vnKy8ur8/6P1Z7t27fXDz/8UKHXu77aAkDNEG4BRFRZL1b5XquSkhI9++yzdpUUwul0KisrSwsXLtQPP/wQnL5169YKYylr68wzz1SbNm303HPPhfxz97vvvqtNmzZpyJAhkgLXBS4qKgpZt1OnTkpISAiut3///go9gKeffrokHXNoQlxcnO666y5t2rRJd911V6W9iP/85z+1cuVKSdKll16qlStXKjs7Ozi/sLBQzz//vDp06KDu3bvXoAWOLzs7O2Tc7K5du/TWW2/pkksuCR5DTqezQt0zZsyoVlivSnXa89JLL5XP59MzzzwTstxf/vIXWZYVtrHZAGqHS4EBiKhzzz1XzZs31+jRo3XzzTfLsiy99NJLDeqfaO+//369//77Ou+88/T73/8+GGR69OihdevWVWsbHo9HDz74YIXpLVq00Lhx4/Too49q7Nixuuiii3T11VcHLwXWoUMH3XLLLZICPZUDBgzQFVdcoe7duysqKkoLFixQbm6urrrqKknS3Llz9eyzz2r48OHq1KmTDhw4oL/97W9KTEzUpZdeeswa77jjDm3YsEFPPPGEPvroo+AdynJycrRw4UKtXLlSn332mSTp7rvv1iuvvKLBgwfr5ptvVosWLTR37lxt27ZN//d//yeHI7x9JT169NDAgQNDLgUmSVOnTg0u84tf/EIvvfSSkpKS1L17d2VnZ+uDDz6o0+W1qtOel112mS6++GJNmjRJ27dvV+/evfX+++/rrbfe0sSJE0NOHgMQeYRbABHVsmVLLVq0SLfddpvuvfdeNW/eXNdcc40GDBiggQMH2l2eJKlv37569913dfvtt2vy5MlKT0/XAw88oE2bNlXrag5SoDd68uTJFaZ36tRJ48aN05gxYxQXF6dHHnlEd911l5o1a6bhw4fr0UcfDZ6xn56erquvvlpLly4N3i0sIyNDr732mkaOHCkpcALUypUrNX/+fOXm5iopKUlnn3225s2bd9wTqBwOh1588UUNHTpUzz//vB5//HEV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af369Ro8eLDi4+OVkpKia6+9Vj/99FNw3f79+2vChAmaOHGiWrVqpYEDB0qSnnzySfXs2VPNmjVTenq6xo0bp4MHD0qSli1bprFjxyo/Pz+4v/vvv19SxWEJO3fu1NChQxUfH6/ExERdccUVys3NDc6///77dfrpp+ull15Shw4dlJSUpKuuukoHDhwILvPGG2+oZ8+eio2NVcuWLZWVlaXCwsJ6ak0AODbCLQDUs6efflqZmZm6/vrrtXv3bu3evVvp6enKy8vTz372M/Xp00erV6/W4sWLlZubqyuuuCJk/blz58rlcunTTz/Vc889J0lyOByaPn26NmzYoLlz5+rDDz/UnXfeKUk699xz9dRTTykxMTG4v9tvv71CXX6/X0OHDtW+ffu0fPlyLVmyRN99952uvPLKkOW+/fZbLVy4UIsWLdKiRYu0fPlyPfLII5Kk3bt36+qrr9Z1112nTZs2admyZRoxYoSMMfXRlABwXAxLAIB6lpSUJJfLpbi4OKWmpganP/PMM+rTp48efvjh4LQXXnhB6enp+uabb9S1a1dJUpcuXfTYY4+FbLP8+N0OHTrowQcf1I033qhnn31WLpdLSUlJsiwrZH9HW7p0qb7++mtt27ZN6enpkqQXX3xRp512mlatWqWzzjpLUiAEz5kzRwkJCZKka6+9VkuXLtVDDz2k3bt3y+v1asSIEWrfvr0kqWfPnnVoLQCoG3puAcAmX375pT766CPFx8cHHxkZGZICvaVl+vbtW2HdDz74QAMGDNBJJ52khIQEXXvttdq7d68OHTpU7f1v2rRJ6enpwWArSd27d1dycrI2bdoUnNahQ4dgsJWktm3bas+ePZKk3r17a8CAAerZs6d+9atf6W9/+5v2799f/UYAgDAj3AKATQ4ePKjLLrtM69atC3ls2bJFF154YXC5Zs2ahay3fft2/eIXv1CvXr30f//3f1qzZo1mzpwpKXDCWbhFR0eHvLYsS36/X5LkdDq1ZMkSvfvuu+revbtmzJihbt26adu2bWGvAwCqg3ALABHgcrnk8/lCpp1xxhnasGGDOnTooM6dO4c8jg605a1Zs0Z+v19PPPGEzjnnHHXt2lU//PDDcfd3tFNPPVW7du3Srl27gtM2btyovLw8de/evdrvzbIsnXfeeZo6darWrl0rl8ulBQsWVHt9AAgnwi0ARECHDh20YsUKbd++XT/99JP8fr/Gjx+vffv26eqrr9aqVav07bff6r333tPYsWOPGUw7d+4sj8ejGTNm6LvvvtNLL70UPNGs/P4OHjyopUuX6qeffqp0uEJWVpZ69uypUaNG6YsvvtDKlSv1m9/8RhdddJHOPPPMar2vFStW6OGHH9bq1au1c+dOvfnmm/rxxx916qmn1qyBACBMCLcAEAG33367nE6nunfvrtatW2vnzp1KS0vTp59+Kp/Pp0suuUQ9e/bUxIkTlZycLIej6q/n3r1768knn9Sjjz6qHj16aN68eZo2bVrIMueee65uvPFGXXnllWrdunWFE9KkQI/rW2+9pebNm+vCCy9UVlaWTjnlFL366qvVfl+JiYn6+OOPdemll6pr166699579cQTT2jw4MHVbxwACCPLcL0WAAAANBH03AIAAKDJINwCAACgySDcAgAAoMkg3AIAAKDJINwCAACgySDcAgAAoMkg3AIAAKDJINwCAACgySDcAgAAoMkg3AIAAKDJINwCAACgyfj/WJdT9eiK3e0AAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        }
      ],
      "source": [
        "plt.figure(figsize=(8,4))\n",
        "plt.plot(baseline_model.loss_history, label=\"Baseline\")\n",
        "plt.plot(mlp_model.loss_history, label=\"MLP\")\n",
        "plt.xlabel(\"Iterations\")\n",
        "plt.ylabel(\"Loss\")\n",
        "plt.legend()\n",
        "plt.title(\"Training Loss Comparison\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 172,
      "metadata": {
        "id": "r6Pj6pQZBBuh",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 507
        },
        "outputId": "76793e12-d64d-4ab9-ea8b-f13bfb26f4b3"
      },
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 800x500 with 1 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAAAxYAAAHqCAYAAACZcdjsAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAW6tJREFUeJzt3Xd0VOXaxuF7z4QUSAIkQEJJIPRipB4UUMAaEAsqRTxItR6wHEUFRRFBOfqp6EEUlGZBRWmiRykWRIoFBUWatNBDCyQhkDrv9wdmYJgJJOyEIfF3rcVa5Jk9e553Zr+TubPLWMYYIwAAAACwweHvBgAAAACUfAQLAAAAALYRLAAAAADYRrAAAAAAYBvBAgAAAIBtBAsAAAAAthEsAAAAANhGsAAAAABgG8ECAAAAgG0EC6AE+L//+z/Vrl1bTqdTzZo183c7KOEWL14sy7K0ePFif7dS5CzL0jPPPOPvNmDDM888I8uy/N0GgHNAsADOwbRp02RZlvtfcHCw6tevr8GDB2vfvn1F+lgLFy7UY489pnbt2mnq1Kl6/vnni3T9f1eLFy/WLbfcoujoaAUGBqpKlSq64YYbNHv2bH+3Bh/ywtDMmTP93UqxOf19JSAgQNWrV1e/fv20e/duf7cHmxITE92v7ejRo30u889//lOWZSk0NNSj3rFjR1100UVnXH9eIMv7V7ZsWTVu3FjDhw9XampqkY0DOJMAfzcAlGTPPvus4uLilJGRoaVLl+rNN9/UF198oT/++ENly5Ytksf45ptv5HA4NHnyZAUGBhbJOv/uRowYoWeffVb16tXTPffco5o1a+rQoUP64osvdOutt2r69Om6/fbb/d1msWnfvr2OHz9eKren48ePKyCgZP9qO/V95YcfftC0adO0dOlS/fHHHwoODvZ3e8Vu+PDhGjp0qL/bKDbBwcH68MMPNXz4cI96enq6Pv30U9uv8ZtvvqnQ0FAdPXpUCxcu1HPPPadvvvlGy5YtY08Qil3JfvcF/Kxz585q1aqVJOnOO+9UZGSkXnnlFX366afq1auXrXUfO3ZMZcuW1f79+xUSElJkHwKNMcrIyFBISEiRrK+kmTlzpp599ll169ZNH3zwgcqUKeO+7dFHH9WCBQuUnZ3txw6LT0ZGhgIDA+VwOErtB9QLfVzp6ekqV67cGZc5/X2lUqVKeuGFFzRv3jz16NHjfLQpyX/vFQEBASU+HJ7Jddddp9mzZ+u3335T06ZN3fVPP/1UWVlZ6tSpk7755ptzXn+3bt1UqVIlSdK9996rW2+9VbNnz9YPP/ygNm3a2O4fOBMOhQKK0JVXXilJ2rZtm7v2/vvvq2XLlgoJCVFERIRuu+027dy50+N+ebu5f/nlF7Vv315ly5bVE088IcuyNHXqVKWnp7t3b0+bNk2SlJOTo1GjRqlOnToKCgpSrVq19MQTTygzM9Nj3bVq1dL111+vBQsWqFWrVgoJCdHEiRPdh5Z8/PHHGjlypKpXr66wsDB169ZNKSkpyszM1EMPPaQqVaooNDRU/fv391r31KlTdeWVV6pKlSoKCgpS48aN9eabb3o9L3k9LF26VK1bt1ZwcLBq166td99912vZI0eO6N///rdq1aqloKAg1ahRQ3369NHBgwfdy2RmZmrEiBGqW7eugoKCFBMTo8cee8yrP1+eeuopRUREaMqUKR6hIk9CQoKuv/5698/79+/XwIEDFRUVpeDgYDVt2lTvvPOOx33yDnF46aWXNH78eNWuXVtly5bVtddeq507d8oYo1GjRqlGjRoKCQnRTTfdpOTkZJ/P0cKFC9WsWTMFBwercePGXodmJScna8iQIYqPj1doaKjCw8PVuXNn/fbbbx7L5b2+H330kYYPH67q1aurbNmySk1N9XmOxaZNm3TrrbcqOjpawcHBqlGjhm677TalpKS4lynsNleQ13vLli3asmVLPq9W4Z1+jkXe4SGbN29Wv379VKFCBZUvX179+/fXsWPHvO5fkPn6/fffq3v37oqNjXVvf//+9791/Phxj+X69eun0NBQbdmyRdddd53CwsL0z3/+s9BjuvzyyyXJ63nasGGDunXrpoiICAUHB6tVq1aaN2+e1/1///13dejQQSEhIapRo4ZGjx6tqVOnyrIsJSYmupfL771COjEvH3roIcXExCgoKEh169bVCy+8IJfL5fFYH330kVq2bKmwsDCFh4crPj5er732mvv27OxsjRw5UvXq1VNwcLAiIyN12WWXadGiRe5lfJ1jURzb3qmys7MVERGh/v37e92Wmpqq4OBgDRkyxF0bN26cmjRporJly6pixYpq1aqVPvjggzM+Rp42bdooLi7Oa/np06erU6dOioiIKNB6CsrX7yWguJTePwkAfpD3iz8yMlKS9Nxzz+mpp55Sjx49dOedd+rAgQMaN26c2rdvr1WrVqlChQru+x46dEidO3fWbbfdpt69eysqKkqtWrXSW2+9pZ9++kmTJk2SJLVt21bSib9kvvPOO+rWrZseeeQR/fjjjxozZozWr1+vOXPmePS1ceNG9erVS/fcc4/uuusuNWjQwH3bmDFjFBISoqFDh2rz5s0aN26cypQpI4fDocOHD+uZZ55xH44RFxenp59+2n3fN998U02aNNGNN96ogIAAffbZZ/rXv/4ll8ulQYMGefSwefNmdevWTQMHDlTfvn01ZcoU9evXTy1btlSTJk0kSUePHtXll1+u9evXa8CAAWrRooUOHjyoefPmadeuXapUqZJcLpduvPFGLV26VHfffbcaNWqkNWvWaOzYsfrzzz81d+7cfF+fTZs2acOGDRowYIDCwsLO+noeP35cHTt21ObNmzV48GDFxcXpk08+Ub9+/XTkyBE9+OCDHstPnz5dWVlZuv/++5WcnKwXX3xRPXr00JVXXqnFixfr8ccfdz/HQ4YM0ZQpU7z669mzp+6991717dtXU6dOVffu3TV//nxdc801kqStW7dq7ty56t69u+Li4rRv3z5NnDhRHTp00Lp161StWjWPdY4aNUqBgYEaMmSIMjMzfe75ysrKUkJCgjIzM3X//fcrOjpau3fv1ueff64jR46ofPnykgq3zRXk9Zakq666SpI8PuAWhx49eiguLk5jxozRr7/+qkmTJqlKlSp64YUX3MsUdL5+8sknOnbsmO677z5FRkbqp59+0rhx47Rr1y598sknHo+bk5OjhIQEXXbZZXrppZfO6RDJvOemYsWK7tratWvVrl07Va9eXUOHDlW5cuX08ccfq2vXrpo1a5ZuvvlmSdLu3bt1xRVXyLIsDRs2TOXKldOkSZMUFBTk87F8vVccO3ZMHTp00O7du3XPPfcoNjZWy5cv17Bhw7R37169+uqrkqRFixapV69euuqqq9zP6/r167Vs2TL3XHnmmWc0ZswY3XnnnWrdurVSU1O1cuVK/frrr+5t3Jfi2PZOVaZMGd18882aPXu2Jk6c6DFP5s6dq8zMTN12222SpLffflsPPPCAunXrpgcffFAZGRn6/fff9eOPPxb4EMpevXrp/fff13/+8x9ZlqWDBw9q4cKFeu+99zR//vwCraOgTv+9BBQrA6DQpk6daiSZr776yhw4cMDs3LnTfPTRRyYyMtKEhISYXbt2mcTERON0Os1zzz3ncd81a9aYgIAAj3qHDh2MJDNhwgSvx+rbt68pV66cR2316tVGkrnzzjs96kOGDDGSzDfffOOu1axZ00gy8+fP91j222+/NZLMRRddZLKystz1Xr16GcuyTOfOnT2Wb9OmjalZs6ZH7dixY179JiQkmNq1a3vU8npYsmSJu7Z//34TFBRkHnnkEXft6aefNpLM7NmzvdbrcrmMMca89957xuFwmO+//97j9gkTJhhJZtmyZV73zfPpp58aSWbs2LH5LnOqV1991Ugy77//vruWlZVl2rRpY0JDQ01qaqoxxpht27YZSaZy5crmyJEj7mWHDRtmJJmmTZua7Oxsd71Xr14mMDDQZGRkuGt5z9GsWbPctZSUFFO1alXTvHlzdy0jI8Pk5uZ69Llt2zYTFBRknn32WXct7/WtXbu21+uUd9u3335rjDFm1apVRpL55JNP8n0uzmWbO9vrnbfs6duVL3k9n6lHY4yRZEaMGOH+ecSIEUaSGTBggMdyN998s4mMjHT/XJj56mu7HzNmjLEsy2zfvt1d69u3r5Fkhg4detbxGeP7fWXmzJmmcuXKJigoyOzcudO97FVXXWXi4+M9tiGXy2Xatm1r6tWr567df//9xrIss2rVKnft0KFDJiIiwkgy27Ztc9fze68YNWqUKVeunPnzzz896kOHDjVOp9Ps2LHDGGPMgw8+aMLDw01OTk6+Y2zatKnp0qXLGZ+HvNcsT3Fte6dbsGCBkWQ+++wzj/p1113n8Z520003mSZNmpxxXb7kvU/83//9n/njjz+MJPf72Pjx401oaKhJT0/3+Z7foUOHsz5m3vO2ceNGc+DAAbNt2zYzceJEExQUZKKiokx6enqhewYKi0OhABuuvvpqVa5cWTExMbrtttsUGhqqOXPmqHr16po9e7ZcLpd69OihgwcPuv9FR0erXr16+vbbbz3WFRQU5HM3vC9ffPGFJOnhhx/2qD/yyCOSpP/9738e9bi4OCUkJPhcV58+fTwOCbrkkktkjNGAAQM8lrvkkku0c+dO5eTkuGunHnudkpKigwcPqkOHDtq6davHITSS1LhxY/chHZJUuXJlNWjQQFu3bnXXZs2apaZNm7r/2nqqvEMjPvnkEzVq1EgNGzb0eF7zdvef/ryeKu/KKAXZWyGdeJ6jo6M9zpcpU6aMHnjgAR09elTfffedx/Ldu3d3/3VfOvGcSVLv3r09jhm/5JJLlJWV5XWln2rVqnmMPTw8XH369NGqVauUlJQk6cR24nCceOvOzc3VoUOHFBoaqgYNGujXX3/1GkPfvn3Peox8Xs8LFizweXhQ3nMhFXybK8jrLZ34a3xx762QThxrfqrLL79chw4dcm8ThZmvpz6f6enpOnjwoNq2bStjjFatWuX12Pfdd1+hej31faVbt24qV66c5s2bpxo1akg6cTjcN998ox49eigtLc3d66FDh5SQkKBNmza5t6358+erTZs2HpepjoiIyPeQLF/vFZ988okuv/xyVaxY0eO5ufrqq5Wbm6slS5ZIkipUqKD09HSPw5pOV6FCBa1du1abNm0q8PNRXNve6a688kpVqlRJM2bMcNcOHz6sRYsWqWfPnh5j2LVrl37++ecCj+F0TZo00cUXX6wPP/xQkvTBBx/opptuKpKLfjRo0ECVK1dWXFyc7rnnHtWtW1f/+9//iuyCIsCZcCgUYMP48eNVv359BQQEKCoqSg0aNHB/6Nu0aZOMMapXr57P+55+fH/16tULfIL29u3b5XA4VLduXY96dHS0KlSooO3bt3vU4+Li8l1XbGysx895HzJjYmK86i6XSykpKe5d6suWLdOIESO0YsUKrw+kKSkpHh+yT38c6cShHYcPH3b/vGXLFt1666359iqdeF7Xr1+vypUr+7x9//79+d43PDxckpSWlnbGx8izfft21atXz/2a5mnUqJH79lMV5rmU5DF2Sapbt67XseX169eXdOIDeHR0tFwul1577TW98cYb2rZtm3Jzc93L+jrU4Uyv/anLPPzww3rllVc0ffp0XX755brxxhvVu3dvd6+F3eYK8nqfT6f3k3dY0eHDhxUeHl6o+bpjxw49/fTTmjdvntd4Tg/UAQEB7kBQUHnvKykpKZoyZYqWLFnicejS5s2bZYzRU089paeeesrnOvbv36/q1atr+/btPk/YPf11zONre9m0aZN+//33s865f/3rX/r444/VuXNnVa9eXddee6169OihTp06uZd99tlnddNNN6l+/fq66KKL1KlTJ91xxx26+OKL830+zte2FxAQoFtvvVUffPCBMjMzFRQUpNmzZys7O9sjWDz++OP66quv1Lp1a9WtW1fXXnutbr/9drVr1+6M6z/d7bffrpdffln//ve/tXz5cj3xxBOFun9+Zs2apfDwcJUpU0Y1atRQnTp1imS9QEEQLAAbWrdu7b56y+lcLpcsy9KXX34pp9Ppdfvp1yk/lyuvFPTSgWdat6/ezlQ3xkg6EQKuuuoqNWzYUK+88opiYmIUGBioL774QmPHjvU6qfNs6ysol8ul+Ph4vfLKKz5vP/1D/KkaNmwoSVqzZk2hHrOgzvW5LIznn39eTz31lAYMGKBRo0YpIiJCDodDDz30kNdzLhV8u3r55ZfVr18/ffrpp1q4cKEeeOABjRkzRj/88IPHB+OCbnNFOeaicLZ+Cjpfc3Nzdc011yg5OVmPP/64GjZsqHLlymn37t3q16+f12tw6h6mgjr1faVr16667LLLdPvtt2vjxo0KDQ11P8aQIUPy3ROZX3A4G1/bi8vl0jXXXKPHHnvM533ywm+VKlW0evVqLViwQF9++aW+/PJLTZ06VX369HFf8KB9+/basmWLezubNGmSxo4dqwkTJujOO+88Y2/nY9u77bbbNHHiRH355Zfq2rWrPv74YzVs2NDj6k2NGjXSxo0b9fnnn2v+/PmaNWuW3njjDT399NMaOXJkgXqUTpxnMWzYMN11112KjIzUtddeW+D7nkn79u3dV4UCzjeCBVBM6tSpI2OM4uLi3L94i0rNmjXlcrm0adMm91/PJWnfvn06cuSIatasWaSP58tnn32mzMxMzZs3z+MvhGc6FOls6tSpoz/++OOsy/z222+66qqrCn1N9vr166tBgwb69NNP9dprr3mFu9PVrFlTv//+u1wul8eHww0bNrhvL0p5f4k+dVx//vmnpBNXu5FOXC73iiuu0OTJkz3ue+TIEdsfJuLj4xUfH6/hw4dr+fLlateunSZMmKDRo0dfENtccSrofF2zZo3+/PNPvfPOO+rTp4+7fqbDf+xwOp0aM2aMrrjiCr3++usaOnSoateuLenEXpSrr776jPevWbOmNm/e7FX3VctPnTp1dPTo0bM+liQFBgbqhhtu0A033CCXy6V//etfmjhxop566il32Mm7+lL//v119OhRtW/fXs8880y+weJ8bnvt27dX1apVNWPGDF122WX65ptv9OSTT3otV65cOfXs2VM9e/ZUVlaWbrnlFj333HMaNmxYgS95HBsbq3bt2mnx4sW67777SvUldvH3wTkWQDG55ZZb5HQ6NXLkSK+/lBljdOjQoXNe93XXXSdJ7qux5Mn7K36XLl3Oed0FlfdXwVPHlpKSoqlTp57zOm+99Vb99ttvXld5OfVxevTood27d+vtt9/2Wub48eNKT08/42OMHDlShw4d0p133ulxvkiehQsX6vPPP5d04nlOSkryOOY6JydH48aNU2hoqDp06FCo8Z3Nnj17PMaempqqd999V82aNVN0dLSkE8/76dvTJ598YuubmVNTU72ei/j4eDkcDvflPItrmyvqy82eq4LOV1/bvTHG45KqRa1jx45q3bq1Xn31VWVkZKhKlSrq2LGjJk6cqL1793otf+DAAff/ExIStGLFCq1evdpdS05O1vTp0wv8+D169NCKFSu0YMECr9uOHDni3nZOf09zOBzuQ5zytqPTlwkNDVXdunXPeKno8/l+53A41K1bN3322Wd67733lJOT43EYlOQ9hsDAQDVu3FjGmEJ/B87o0aM1YsQI3X///bZ7By4ExGOgmNSpU0ejR4/WsGHDlJiYqK5duyosLEzbtm3TnDlzdPfdd3tcF70wmjZtqr59++qtt97SkSNH1KFDB/30009655131LVrV11xxRVFPBpv1157rfuvk/fcc4+OHj2qt99+W1WqVPH5YacgHn30Uc2cOVPdu3fXgAED1LJlSyUnJ2vevHmaMGGCmjZtqjvuuEMff/yx7r33Xn377bdq166dcnNztWHDBn388cfua/Dnp2fPnlqzZo2ee+45rVq1Sr169XJ/8/b8+fP19ddfu68vf/fdd2vixInq16+ffvnlF9WqVUszZ87UsmXL9Oqrrxb4JPCCql+/vgYOHKiff/5ZUVFRmjJlivbt2+cR1q6//no9++yz6t+/v9q2bas1a9Zo+vTp7r9in4tvvvlGgwcPVvfu3VW/fn3l5OTovffek9PpdJ/zUlzbXGEvNztr1iz3HqNT9e3b94yHwZ1NQedrw4YNVadOHQ0ZMkS7d+9WeHi4Zs2aVeznjjz66KPq3r27pk2bpnvvvVfjx4/XZZddpvj4eN11112qXbu29u3bpxUrVmjXrl3u7zV57LHH9P777+uaa67R/fff777cbGxsrJKTkwu01+/RRx/VvHnzdP3117sv25qenq41a9Zo5syZSkxMVKVKlXTnnXcq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62rq1Km67rrrtG7dOlWpUsW912D69Ole96tcuXKBx+yrn6NHj+qGG27QCy+84LVs1apV5XQ6tWjRIi1fvlwLFy7UuHHj9OSTT+rHH39UXFycpk6dqgceeEDz58/XjBkzNHz4cC1atEiXXnppofo61Zlem+JCsPCT87079O+gsLt8AQBA8WnRooXWrVununXr+rx9zZo1OnTokP7zn/8oJiZG0olDoYpK69at1bJlSz333HN67bXX1KJFC82YMUNVqlTJ95CeqKgo/fzzz2rfvr2kE4dC/frrr2f9HokWLVpo1qxZqlWrlgICfH+8tixL7dq1U7t27fT000+rZs2amjNnjh5++GFJUvPmzdW8eXMNGzZMbdq00QcffOAVLMLDw1WtWjUtW7bM47CpZcuWeexp8RcOhQIAAIAkKSUlRatXr/b4t3PnznNa1+OPP67ly5dr8ODBWr16tTZt2qRPP/3UffJ2bGysAgMDNW7cOG3dulXz5s3TqFGjinI4euihhzRx4kTt3r1b//znP1WpUiXddNNN+v7777Vt2zYtXrxYDzzwgHbt2iVJuv/++zVmzBh9+umn2rhxox588EEdPnw43xOp8wwaNEjJycnq1auXfv75Z23ZskULFixQ//79lZubqx9//FHPP/+8Vq5cqR07dmj27Nk6cOCAGjVqpG3btmnYsGFasWKFtm/froULF2rTpk1q1KiRz8d69NFH9cILL2jGjBnauHGjhg4dqtWrV+vBBx8s0ufuXLDHAgAAAJJOXPa0efPmHrWBAwdq0qRJhV7XxRdfrO+++05PPvmkLr/8chljVKdOHfXs2VPSicOPpk2bpieeeEL//e9/1aJFC7300ku68cYbi2QsktSpUyfFxcXpueee0xtvvKElS5bo8ccf1y233KK0tDRVr15dV111lXsPxuOPP66kpCT16dNHTqdTd999txISEuR0Os/4OHl7ER5//HFde+21yszMVM2aNdWpUyc5HA6Fh4dryZIlevXVV5WamqqaNWvq5ZdfVufOnbVv3z5t2LBB77zzjg4dOqSqVatq0KBBuueee3w+1gMPPKCUlBQ98sgj2r9/vxo3bqx58+apXr16Rfa8nSuuCuUnHApV9DgUCgBwITjTFXZQsrhcLjVq1Eg9evQo8r0pF5KiuioUeywAAAAAyX0oUocOHZSZmanXX39d27Zt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NWjQQL1799aUKVPE1ywBJUN+v7tPlZKSooiIiPPYFfyBYAG/+/zzzxUaGqrg4GDFx8dr//79evTRR72WGzBggKZMmSJJmjZtmq677jpVrlzZY5nu3burV69e6tChg6pWraqbb75Zr7/+ulJTU73WV6NGDYWGhrr/NWnSpHgGCPyN9e7dW0uXLtX27du1fft2LVu2TL179/ZabvLkye56p06dlJKSou+++85rubZt23rM29MPhwRwfhT0d7ckbd68WePGjdM999xznrvE+Rbg7waAK664Qm+++abS09M1duxYBQQE6NZbb/Varnfv3ho6dKi2bt2qadOm6b///a/XMk6nU1OnTtXo0aP1zTff6Mcff9Tzzz+vF154QT/99JOqVq3qXvb7779XWFiY+2cOpwCKXuXKld2HNhlj1KVLF1WqVMljmY0bN+qnn37SnDlzJEkBAQHq2bOnJk+erI4dO3osO2PGDDVq1Oh8tQ8gHwX93b1792516tRJ3bt311133eWHTnE+ESzgd+XKlVPdunUlnThMomnTppo8ebIGDhzosVxkZKSuv/56DRw4UBkZGercubPS0tJ8rrN69eq64447dMcdd2jUqFGqX7++JkyYoJEjR7qXiYuLU4UKFYptXABOGDBggAYPHixJGj9+vNftkydPVk5OjqpVq+auGWMUFBSk119/XeXLl3fXY2Ji3O8XAPynIL+79+zZoyuuuEJt27bVW2+95a9WcR5xKBQuKA6HQ0888YSGDx/ucaJ2ngEDBmjx4sXq06ePnE5ngdZZsWJFVa1aVenp6UXdLoAC6NSpk7KyspSdna2EhASP23JycvTuu+/q5Zdf1urVq93/fvvtN1WrVk0ffvihn7oGUFC+fnfv3r1bHTt2VMuWLTV16lQujvI3wR4LXHC6d++uRx99VOPHj9eQIUM8buvUqZMOHDig8PBwn/edOHGiVq9erZtvvll16tRRRkaG3n33Xa1du1bjxo3zWHb//v0e35chndgrwiFRQNFyOp1av369+/+n+vzzz3X48GENHDjQY8+EJN16662aPHmyx3dhHDp0yOv7ZipUqKDg4OBi6h5AQZz6u7tXr17q2LGjatasqZdeekkHDhxwLxcdHe3HLlHcCBa44AQEBGjw4MF68cUXdd9993ncZlmW1/HZp2rdurWWLl2qe++9V3v27HGflD137lx16NDBY9kGDRp43X/FihW69NJLi2YgANzy+2PA5MmTdfXVV3uFCulEsHjxxRf1+++/u+9/9dVXey334Ycf6rbbbivahgEUyqm/u0NCQrR582Zt3rxZNWrU8FiOq72VbpbhFQYAAABgEwe8AQAAALCNYAEAAADANoIFAAAAANsIFgAAAABsI1gAAAAAsI1gAQAAAMA2ggUAAAAA2wgWAAAAAGwjWAAAAACwjWABAAAAwDaCBQAAAADbCBYAAAAAbPt/GK6SdIHF2EAAAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        }
      ],
      "source": [
        "# 2. Performance comparison bar chart\n",
        "# TODO: Create bar chart comparing key metrics between models\n",
        "plt.figure(figsize=(8, 5))\n",
        "metrics = [\"RMSE\", \"MAE\", \"R2\"]\n",
        "\n",
        "linear_values = [\n",
        "    baseline_metrics[\"RMSE\"],\n",
        "    baseline_metrics[\"MAE\"],\n",
        "    baseline_metrics[\"R2\"]\n",
        "]\n",
        "\n",
        "mlp_values = [\n",
        "    mlp_metrics[\"RMSE\"],\n",
        "    mlp_metrics[\"MAE\"],\n",
        "    mlp_metrics[\"R2\"]\n",
        "]\n",
        "\n",
        "x = np.arange(len(metrics))\n",
        "width = 0.35\n",
        "\n",
        "plt.bar(x - width/2, linear_values, width, label=\"Linear Regression\")\n",
        "plt.bar(x + width/2, mlp_values, width, label=\"MLP\")\n",
        "\n",
        "plt.xticks(x, metrics)\n",
        "plt.ylabel(\"Metric Value\")\n",
        "plt.title(\"Performance Comparison: Linear Regression vs MLP\")\n",
        "plt.legend()\n",
        "plt.grid(axis=\"y\", linestyle=\"--\", alpha=0.6)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Ua107rhpBBuh"
      },
      "source": [
        "## Section 7: Analysis and Discussion\n",
        "\n",
        "Write your analysis (minimum 200 words)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 173,
      "metadata": {
        "id": "0fdNLJqCBBuh"
      },
      "outputs": [],
      "source": [
        "analysis_text = \"\"\"\n",
        "1. Model Performance Comparison\n",
        "- The Multi-Layer Perceptron (MLP) model performed better than the baseline linear regression model across all evaluated metrics.\n",
        "- The baseline model achieved an MSE of 5.03, RMSE of approximately 2.24, MAE of 1.62, and an R2 score of 0.536.\n",
        "- In comparison, the MLP reduced the MSE to 4.48, RMSE to about 2.12, and MAE to 1.49, while improving the R² score to 0.585.\n",
        "- Overall, the MLP explained around 5% more variance in the target variable and produced lower prediction errors.\n",
        "\n",
        "2. Reason for Performance Difference\n",
        "- Linear regression assumes a strictly linear relationship between features and the target variable.\n",
        "- The dataset contains non-linear relationships and feature interactions that cannot be fully captured by a linear model.\n",
        "- The MLP, with hidden layers and ReLU activations, was able to learn these non-linear patterns, leading to improved predictive performance.\n",
        "\n",
        "3. Computational Cost Comparison\n",
        "- The baseline linear regression model trained very quickly due to its simple architecture and convex optimization.\n",
        "- The MLP required significantly more training time because of multiple layers, backpropagation, and a larger number of parameters.\n",
        "- Despite the higher computational cost, the performance gains achieved by the MLP justified the additional training time.\n",
        "\n",
        "4. Challenges and Surprising Observations\n",
        "- A key challenge was tuning the MLP hyperparameters, such as learning rate, network architecture, and number of training iterations.\n",
        "- Initial MLP configurations performed worse than the linear model, highlighting the sensitivity of neural networks to proper tuning.\n",
        "- After adjustments, the MLP consistently outperformed the baseline.\n",
        "\n",
        "5. Key Insights Gained\n",
        "- Linear models provide strong, fast, and reliable baselines for regression problems.\n",
        "- Neural networks offer greater representational power but require careful tuning and higher computational cost.\n",
        "- This study demonstrated that MLPs are better suited for modeling complex, non-linear relationships when sufficient data and proper optimization are applied.\n",
        "\"\"\"\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7e3C2Bf4BBuh"
      },
      "source": [
        "---\n",
        "---\n",
        "\n",
        "## ⭐ REQUIRED: Structured Output Function\n",
        "\n",
        "### **DO NOT MODIFY THE STRUCTURE BELOW**\n",
        "\n",
        "This function will be called by the auto-grader. Fill in all values accurately based on your actual results.\n",
        "\n",
        "\n",
        "⭐⭐⭐ REQUIRED: Structured Output Function ⭐⭐⭐\n",
        "\n",
        "### 🚨 CRITICAL - READ CAREFULLY 🚨\n",
        "\n",
        "1. **Fill in ALL fields** - Missing fields = 0 marks\n",
        "2. **Use your actual values** - Not 0 or empty strings\n",
        "3. **This cell MUST be executed** - We need the output!\n",
        "4. **Print the results** - Auto-grader needs to see output!\n",
        "\n",
        "\n",
        "**DO NOT:**\n",
        "- Leave any field as 0, 0.0,\n",
        "- Clear outputs before submission\n",
        "- Modify the structure\n",
        "\n",
        "\n",
        "\"**MUST DO:**\n",
        "- Fill every field with your actual results\n",
        "- Execute this cell and keep the output\n",
        "- Print the results (see below)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 174,
      "metadata": {
        "id": "w1W6qvYzBBuh",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "6090bf2b-3bd6-4b39-9014-6db346a78529"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "{\n",
            "  \"dataset_name\": \"UCI Abalone Dataset \",\n",
            "  \"dataset_source\": \"Public UCI dataset \",\n",
            "  \"n_samples\": 4177,\n",
            "  \"n_features\": 8,\n",
            "  \"problem_type\": \"regression\",\n",
            "  \"problem_statement\": \"\\nThe Abalone dataset contains physical measurements of marine mollusks and aims to predict the number of shell rings,which is correlated with age. \\nSince the relationship between physical attributes and age is non-linear, this dataset is well-suited for comparing linear regression with a multi-layer perceptron.\\\"\\n\",\n",
            "  \"primary_metric\": \"r2\",\n",
            "  \"metric_justification\": \"R\\u00b2 represents the proportion of variance in the target variable (Rings, which correlates with abalone age) that is explained by the input features.\\\"\\n\",\n",
            "  \"train_samples\": 3341,\n",
            "  \"test_samples\": 836,\n",
            "  \"train_test_ratio\": 3.9964114832535884,\n",
            "  \"baseline_model\": {\n",
            "    \"model_type\": \"linear_regression\",\n",
            "    \"learning_rate\": 0.01,\n",
            "    \"n_iterations\": 3000,\n",
            "    \"initial_loss\": 109.17958695001496,\n",
            "    \"final_loss\": 4.865054118047102,\n",
            "    \"training_time_seconds\": 1.6393136978149414,\n",
            "    \"loss_decreased\": \"True\",\n",
            "    \"test_accuracy\": 0.0,\n",
            "    \"test_precision\": 0.0,\n",
            "    \"test_recall\": 0.0,\n",
            "    \"test_f1\": 0.0,\n",
            "    \"test_mse\": 5.026721840887425,\n",
            "    \"test_rmse\": 2.242035200635223,\n",
            "    \"test_mae\": 1.6206206310973115,\n",
            "    \"test_r2\": 0.5356467154232925\n",
            "  },\n",
            "  \"mlp_model\": {\n",
            "    \"architecture\": [\n",
            "      9,\n",
            "      32,\n",
            "      8,\n",
            "      1\n",
            "    ],\n",
            "    \"n_hidden_layers\": 2,\n",
            "    \"learning_rate\": 0.01,\n",
            "    \"n_iterations\": 1000,\n",
            "    \"initial_loss\": 113.45223294836968,\n",
            "    \"final_loss\": 3.9762102800984107,\n",
            "    \"training_time_seconds\": 11.041512489318848,\n",
            "    \"loss_decreased\": \"True\",\n",
            "    \"test_accuracy\": 0.0,\n",
            "    \"test_precision\": 0.0,\n",
            "    \"test_recall\": 0.0,\n",
            "    \"test_f1\": 0.0,\n",
            "    \"test_mse\": 4.4174297693903934,\n",
            "    \"test_rmse\": 2.1017682482591638,\n",
            "    \"test_mae\": 1.4918964667063248,\n",
            "    \"test_r2\": 0.5919312650008844\n",
            "  },\n",
            "  \"analysis\": \"\\n1. Model Performance Comparison\\n- The Multi-Layer Perceptron (MLP) model performed better than the baseline linear regression model across all evaluated metrics.\\n- The baseline model achieved an MSE of 5.03, RMSE of approximately 2.24, MAE of 1.62, and an R2 score of 0.536.\\n- In comparison, the MLP reduced the MSE to 4.48, RMSE to about 2.12, and MAE to 1.49, while improving the R\\u00b2 score to 0.585.\\n- Overall, the MLP explained around 5% more variance in the target variable and produced lower prediction errors.\\n\\n2. Reason for Performance Difference\\n- Linear regression assumes a strictly linear relationship between features and the target variable.\\n- The dataset contains non-linear relationships and feature interactions that cannot be fully captured by a linear model.\\n- The MLP, with hidden layers and ReLU activations, was able to learn these non-linear patterns, leading to improved predictive performance.\\n\\n3. Computational Cost Comparison\\n- The baseline linear regression model trained very quickly due to its simple architecture and convex optimization.\\n- The MLP required significantly more training time because of multiple layers, backpropagation, and a larger number of parameters.\\n- Despite the higher computational cost, the performance gains achieved by the MLP justified the additional training time.\\n\\n4. Challenges and Surprising Observations\\n- A key challenge was tuning the MLP hyperparameters, such as learning rate, network architecture, and number of training iterations.\\n- Initial MLP configurations performed worse than the linear model, highlighting the sensitivity of neural networks to proper tuning.\\n- After adjustments, the MLP consistently outperformed the baseline.\\n\\n5. Key Insights Gained\\n- Linear models provide strong, fast, and reliable baselines for regression problems.\\n- Neural networks offer greater representational power but require careful tuning and higher computational cost.\\n- This study demonstrated that MLPs are better suited for modeling complex, non-linear relationships when sufficient data and proper optimization are applied.\\n\",\n",
            "  \"analysis_word_count\": 309\n",
            "}\n",
            "\n",
            "============================================================\n",
            "VALIDATION CHECK\n",
            "============================================================\n",
            "✅ All validation checks passed!\n",
            "✅ Ready to submit!\n",
            "Next steps:\n",
            "1. Kernel → Restart & Clear Output\n",
            "2. Kernel → Restart & Run All\n",
            "3. Verify this output is visible\n",
            "4. Save notebook\n",
            "5. Rename as: YourStudentID_assignment.ipynb\n",
            "6. Submit to LMS\n"
          ]
        }
      ],
      "source": [
        "def get_assignment_results():\n",
        "    '''\n",
        "    CRITICAL: Fill ALL fields with your actual results!\n",
        "    Missing fields will result in 0 marks for that section.\n",
        "    '''\n",
        "\n",
        "    results = {\n",
        "        # ===== Dataset Information (1 mark) =====\n",
        "        'dataset_name': dataset_name,  # MUST fill\n",
        "        'dataset_source': dataset_source,  # MUST fill\n",
        "        'n_samples': n_samples,  # MUST be ≥500\n",
        "        'n_features': n_features,  # MUST be ≥5\n",
        "        'problem_type': problem_type,  # MUST fill\n",
        "        'problem_statement': problem_statement,  # MUST be ≥50 words\n",
        "        'primary_metric': primary_metric,  # MUST fill\n",
        "        'metric_justification': metric_justification,  # MUST be ≥30 words\n",
        "        'train_samples': train_samples,\n",
        "        'test_samples': test_samples,\n",
        "        'train_test_ratio': train_test_ratio,\n",
        "\n",
        "        # ===== Baseline Model (3 marks) =====\n",
        "        'baseline_model': {\n",
        "            'model_type': 'linear_regression',  # 'linear_regression', 'logistic_regression', 'softmax_regression'\n",
        "            'learning_rate': 0.01,  # Your learning rate\n",
        "            'n_iterations': 3000,  # Your iterations\n",
        "\n",
        "            # CRITICAL: These MUST be filled!\n",
        "            'initial_loss': baseline_initial_loss,  # MUST NOT be 0\n",
        "            'final_loss': baseline_final_loss,  # MUST NOT be 0\n",
        "            'training_time_seconds': baseline_training_time,  # MUST NOT be 0\n",
        "            'loss_decreased': f\"{baseline_final_loss < baseline_initial_loss}\",  # Auto-calculated\n",
        "\n",
        "            # Metrics - Fill based on your problem type\n",
        "            'test_accuracy': 0.0 if problem_type == 'regression' else baseline_acc,\n",
        "            'test_precision': 0.0 if problem_type == 'regression' else baseline_prec,\n",
        "            'test_recall': 0.0 if problem_type == 'regression' else baseline_rec,\n",
        "            'test_f1': 0.0 if problem_type == 'regression' else baseline_f1,\n",
        "            'test_mse': baseline_mse if problem_type == 'regression' else 0.0,\n",
        "            'test_rmse': baseline_rmse if problem_type == 'regression' else 0.0,\n",
        "            'test_mae': baseline_mae if problem_type == 'regression' else 0.0,\n",
        "            'test_r2': baseline_r2 if problem_type == 'regression' else 0.0,\n",
        "        },\n",
        "\n",
        "        # ===== MLP Model (4 marks) =====\n",
        "        'mlp_model': {\n",
        "            'architecture': mlp_architecture,  # MUST have ≥3 elements\n",
        "            'n_hidden_layers': len(mlp_architecture) - 2 if len(mlp_architecture) > 0 else 0,\n",
        "            'learning_rate': 0.01,\n",
        "            'n_iterations': 1000,\n",
        "\n",
        "            # CRITICAL: These MUST be filled!\n",
        "            'initial_loss': mlp_initial_loss,  # MUST NOT be 0\n",
        "            'final_loss': mlp_final_loss,  # MUST NOT be 0\n",
        "            'training_time_seconds': mlp_training_time,  # MUST NOT be 0\n",
        "            'loss_decreased': f\"{mlp_final_loss < mlp_initial_loss}\",  # Auto-calculated\n",
        "\n",
        "            # Metrics\n",
        "            'test_accuracy': 0.0 if problem_type == 'regression' else mlp_acc,\n",
        "            'test_precision': 0.0 if problem_type == 'regression' else mlp_prec,\n",
        "            'test_recall': 0.0 if problem_type == 'regression' else mlp_rec,\n",
        "            'test_f1': 0.0 if problem_type == 'regression' else mlp_f1,\n",
        "            'test_mse': mlp_mse if problem_type == 'regression' else 0.0,\n",
        "            'test_rmse': mlp_rmse if problem_type == 'regression' else 0.0,\n",
        "            'test_mae': mlp_mae if problem_type == 'regression' else 0.0,\n",
        "            'test_r2': mlp_r2 if problem_type == 'regression' else 0.0,\n",
        "        },\n",
        "\n",
        "        # ===== Analysis (2 marks) =====\n",
        "        'analysis': analysis_text,\n",
        "        'analysis_word_count': len(analysis_text.split()),\n",
        "    }\n",
        "\n",
        "    return results\n",
        "\n",
        "# ===== CRITICAL: CALL AND PRINT RESULTS =====\n",
        "# This MUST be executed and output MUST be visible!\n",
        "import json\n",
        "results = get_assignment_results()\n",
        "# print(results)\n",
        "print(json.dumps(results, indent=2))\n",
        "\n",
        "# ===== Validation =====\n",
        "print(\"\\n\" + \"=\"*60)\n",
        "print(\"VALIDATION CHECK\")\n",
        "print(\"=\"*60)\n",
        "\n",
        "\n",
        "errors = []\n",
        "\n",
        "if results['n_samples'] < 500:\n",
        "    errors.append(f\"❌ Dataset too small: {results['n_samples']} < 500\")\n",
        "if results['n_features'] < 5:\n",
        "    errors.append(f\"❌ Too few features: {results['n_features']} < 5\")\n",
        "if results['baseline_model']['initial_loss'] == 0:\n",
        "    errors.append(\"❌ Baseline initial_loss is 0\")\n",
        "if results['baseline_model']['final_loss'] == 0:\n",
        "    errors.append(\"❌ Baseline final_loss is 0\")\n",
        "if results['baseline_model']['training_time_seconds'] == 0:\n",
        "    errors.append(\"❌ Baseline training_time is 0\")\n",
        "if results['mlp_model']['initial_loss'] == 0:\n",
        "    errors.append(\"❌ MLP initial_loss is 0\")\n",
        "if results['mlp_model']['final_loss'] == 0:\n",
        "    errors.append(\"❌ MLP final_loss is 0\")\n",
        "if results['mlp_model']['training_time_seconds'] == 0:\n",
        "    errors.append(\"❌ MLP training_time is 0\")\n",
        "if len(results['mlp_model']['architecture']) < 3:\n",
        "    errors.append(\"❌ MLP architecture invalid\")\n",
        "if results['analysis_word_count'] < 200:\n",
        "    errors.append(f\"❌ Analysis too short: {results['analysis_word_count']} < 200 words\")\n",
        "\n",
        "if errors:\n",
        "    print(\"ERRORS FOUND:\")\n",
        "    for err in errors:\n",
        "        print(err)\n",
        "    print(\" FIX THESE BEFORE SUBMITTING! \")\n",
        "else:\n",
        "    print(\"✅ All validation checks passed!\")\n",
        "    print(\"✅ Ready to submit!\")\n",
        "    print(\"Next steps:\")\n",
        "    print(\"1. Kernel → Restart & Clear Output\")\n",
        "    print(\"2. Kernel → Restart & Run All\")\n",
        "    print(\"3. Verify this output is visible\")\n",
        "    print(\"4. Save notebook\")\n",
        "    print(\"5. Rename as: YourStudentID_assignment.ipynb\")\n",
        "    print(\"6. Submit to LMS\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "JPvwotBWBBuh"
      },
      "source": [
        "## Test Your Output\n",
        "\n",
        "Run this cell to verify your results dictionary is complete and properly formatted."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 175,
      "metadata": {
        "id": "n4mkH-nSBBui",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "53dda47f-b3ab-4740-ba03-0d91a8140b2f"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "======================================================================\n",
            "ASSIGNMENT RESULTS SUMMARY\n",
            "======================================================================\n",
            "{\n",
            "  \"dataset_name\": \"UCI Abalone Dataset \",\n",
            "  \"dataset_source\": \"Public UCI dataset \",\n",
            "  \"n_samples\": 4177,\n",
            "  \"n_features\": 8,\n",
            "  \"problem_type\": \"regression\",\n",
            "  \"problem_statement\": \"\\nThe Abalone dataset contains physical measurements of marine mollusks and aims to predict the number of shell rings,which is correlated with age. \\nSince the relationship between physical attributes and age is non-linear, this dataset is well-suited for comparing linear regression with a multi-layer perceptron.\\\"\\n\",\n",
            "  \"primary_metric\": \"r2\",\n",
            "  \"metric_justification\": \"R\\u00b2 represents the proportion of variance in the target variable (Rings, which correlates with abalone age) that is explained by the input features.\\\"\\n\",\n",
            "  \"train_samples\": 3341,\n",
            "  \"test_samples\": 836,\n",
            "  \"train_test_ratio\": 3.9964114832535884,\n",
            "  \"baseline_model\": {\n",
            "    \"model_type\": \"linear_regression\",\n",
            "    \"learning_rate\": 0.01,\n",
            "    \"n_iterations\": 3000,\n",
            "    \"initial_loss\": 109.17958695001496,\n",
            "    \"final_loss\": 4.865054118047102,\n",
            "    \"training_time_seconds\": 1.6393136978149414,\n",
            "    \"loss_decreased\": \"True\",\n",
            "    \"test_accuracy\": 0.0,\n",
            "    \"test_precision\": 0.0,\n",
            "    \"test_recall\": 0.0,\n",
            "    \"test_f1\": 0.0,\n",
            "    \"test_mse\": 5.026721840887425,\n",
            "    \"test_rmse\": 2.242035200635223,\n",
            "    \"test_mae\": 1.6206206310973115,\n",
            "    \"test_r2\": 0.5356467154232925\n",
            "  },\n",
            "  \"mlp_model\": {\n",
            "    \"architecture\": [\n",
            "      9,\n",
            "      32,\n",
            "      8,\n",
            "      1\n",
            "    ],\n",
            "    \"n_hidden_layers\": 2,\n",
            "    \"learning_rate\": 0.01,\n",
            "    \"n_iterations\": 1000,\n",
            "    \"initial_loss\": 113.45223294836968,\n",
            "    \"final_loss\": 3.9762102800984107,\n",
            "    \"training_time_seconds\": 11.041512489318848,\n",
            "    \"loss_decreased\": \"True\",\n",
            "    \"test_accuracy\": 0.0,\n",
            "    \"test_precision\": 0.0,\n",
            "    \"test_recall\": 0.0,\n",
            "    \"test_f1\": 0.0,\n",
            "    \"test_mse\": 4.4174297693903934,\n",
            "    \"test_rmse\": 2.1017682482591638,\n",
            "    \"test_mae\": 1.4918964667063248,\n",
            "    \"test_r2\": 0.5919312650008844\n",
            "  },\n",
            "  \"analysis\": \"\\n1. Model Performance Comparison\\n- The Multi-Layer Perceptron (MLP) model performed better than the baseline linear regression model across all evaluated metrics.\\n- The baseline model achieved an MSE of 5.03, RMSE of approximately 2.24, MAE of 1.62, and an R2 score of 0.536.\\n- In comparison, the MLP reduced the MSE to 4.48, RMSE to about 2.12, and MAE to 1.49, while improving the R\\u00b2 score to 0.585.\\n- Overall, the MLP explained around 5% more variance in the target variable and produced lower prediction errors.\\n\\n2. Reason for Performance Difference\\n- Linear regression assumes a strictly linear relationship between features and the target variable.\\n- The dataset contains non-linear relationships and feature interactions that cannot be fully captured by a linear model.\\n- The MLP, with hidden layers and ReLU activations, was able to learn these non-linear patterns, leading to improved predictive performance.\\n\\n3. Computational Cost Comparison\\n- The baseline linear regression model trained very quickly due to its simple architecture and convex optimization.\\n- The MLP required significantly more training time because of multiple layers, backpropagation, and a larger number of parameters.\\n- Despite the higher computational cost, the performance gains achieved by the MLP justified the additional training time.\\n\\n4. Challenges and Surprising Observations\\n- A key challenge was tuning the MLP hyperparameters, such as learning rate, network architecture, and number of training iterations.\\n- Initial MLP configurations performed worse than the linear model, highlighting the sensitivity of neural networks to proper tuning.\\n- After adjustments, the MLP consistently outperformed the baseline.\\n\\n5. Key Insights Gained\\n- Linear models provide strong, fast, and reliable baselines for regression problems.\\n- Neural networks offer greater representational power but require careful tuning and higher computational cost.\\n- This study demonstrated that MLPs are better suited for modeling complex, non-linear relationships when sufficient data and proper optimization are applied.\\n\",\n",
            "  \"analysis_word_count\": 309\n",
            "}\n",
            "\n",
            "======================================================================\n",
            "✅ All required fields are filled!\n",
            "\n",
            "🎉 You're ready to submit!\n",
            "\n",
            "Next steps:\n",
            "1. Kernel → Restart & Clear Output\n",
            "2. Kernel → Restart & Run All\n",
            "3. Verify no errors\n",
            "4. Save notebook\n",
            "5. Rename as: YourStudentID_assignment.ipynb\n",
            "6. Submit to LMS\n"
          ]
        }
      ],
      "source": [
        "# Test the output\n",
        "import json\n",
        "\n",
        "try:\n",
        "    results = get_assignment_results()\n",
        "\n",
        "    print(\"=\"*70)\n",
        "    print(\"ASSIGNMENT RESULTS SUMMARY\")\n",
        "    print(\"=\"*70)\n",
        "    print(json.dumps(results, indent=2))\n",
        "    # print(results)\n",
        "    print(\"\\n\" + \"=\"*70)\n",
        "\n",
        "\n",
        "    # Check for missing values\n",
        "    missing = []\n",
        "    def check_dict(d, prefix=\"\"):\n",
        "        for k, v in d.items():\n",
        "            if isinstance(v, dict):\n",
        "                check_dict(v, f\"{prefix}{k}.\")\n",
        "            elif (v == 0 or v == \"\" or v == 0.0 or v == []) and \\\n",
        "                 k not in ['improvement', 'improvement_percentage', 'baseline_better',\n",
        "                          'baseline_converged', 'mlp_converged', 'total_parameters',\n",
        "                          'test_accuracy', 'test_precision', 'test_recall', 'test_f1',\n",
        "                          'test_mse', 'test_rmse', 'test_mae', 'test_r2']:\n",
        "                missing.append(f\"{prefix}{k}\")\n",
        "\n",
        "    check_dict(results)\n",
        "\n",
        "    if missing:\n",
        "        print(f\"⚠️  Warning: {len(missing)} fields still need to be filled:\")\n",
        "        for m in missing[:15]:  # Show first 15\n",
        "            print(f\"  - {m}\")\n",
        "        if len(missing) > 15:\n",
        "            print(f\"  ... and {len(missing)-15} more\")\n",
        "    else:\n",
        "        print(\"✅ All required fields are filled!\")\n",
        "        print(\"\\n🎉 You're ready to submit!\")\n",
        "        print(\"\\nNext steps:\")\n",
        "        print(\"1. Kernel → Restart & Clear Output\")\n",
        "        print(\"2. Kernel → Restart & Run All\")\n",
        "        print(\"3. Verify no errors\")\n",
        "        print(\"4. Save notebook\")\n",
        "        print(\"5. Rename as: YourStudentID_assignment.ipynb\")\n",
        "        print(\"6. Submit to LMS\")\n",
        "\n",
        "except Exception as e:\n",
        "    print(f\"❌ Error in get_assignment_results(): {str(e)}\")\n",
        "    print(\"\\nPlease fix the errors above before submitting.\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "iuRKuL80BBui"
      },
      "source": [
        "---\n",
        "\n",
        "## 📤 Before Submitting - Final Checklist\n",
        "\n",
        "- [ ] **All TODO sections completed**\n",
        "- [ ] **Both models implemented from scratch** (no sklearn models!)\n",
        "- [ ] **get_assignment_results() function filled accurately**\n",
        "- [ ] **Loss decreases for both models**\n",
        "- [ ] **Analysis ≥ 200 words**\n",
        "- [ ] **All cells run without errors** (Restart & Run All)\n",
        "- [ ] **Visualizations created**\n",
        "- [ ] **File renamed correctly**: YourStudentID_assignment.ipynb\n",
        "\n",
        "---\n",
        "\n",
        "**Good luck! **"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.10"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
